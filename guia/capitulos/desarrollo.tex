\section{Desarrollo del proyecto}

Para la realización de este proyecto se han seguido una serie de pasos de forma cronológica:
\begin{enumerate}
\item \underline{Aprendizaje de \guis}\\
En primer lugar, se estudio el código de iwconfig, para tratar de integrar el comando dentro del proyecto, se pretendía hacer que el programa pudiera conectar a una red seleccionada, pero para ello se necesitan privilegios de administrador, por tanto, se descartó esta posibilidad. También se consideró integrar el código de iwlist junto al codigo del proyecto, pero se descarto esta opción por simplicidad del código.\\

Al mismo tiempo, se lleva a cabo un aprendizaje de funcionamiento de varias librerías gráficas para, junto con el lenguaje a utilizar, llevar a cabo el desarrollo del proyecto. Se descartó Java como lenguaje en detrimento de C/C++ o Python y se empezó a realizar pruebas en C con GTK+, pero fue descartado al pasar a utilizar C++ por dificultades en su integración. Finalmente, se eligió C++ y las librerías Qt\footnote{http://qt.nokia.com/}.Se realizan varias pruebas para practicar con la interactuación de widgets --una de las principales caractrísticas de Qt-- con ejemplos sencillos, como unir el valor de un spinbox con una barra deslizante \ver{prueba1}.\\ 

\figura{0.5}{imgs/capturas/ejemplopruebas.png}{Prueba con widgets de Qt}{prueba1}{h}


\item \underline{Pruebas con las herramientas elegidas}\\

Tras comunicar al tutor la elección del lenguaje y las librerías gáficas, se procedió a realizar un primer diseño de la interfaz gráfica. Esta se pretendía hacerla lo más similar posible a la interfaz del programa original (NetSurveyor), pero la interactividad en la selección de las redes y los gráficos mostrados se dejaron para futuras ampliaciones del proyecto.\\	

\figura{0.7}{imgs/capturas/netsurveyor.png}{Vista del programa NetSurveyor}{netsurveyor}{h}


Durante el análisis y desarrollo del proyecto, se estudió el lenguaje Java, pero al no contar con experiencia en este lenguaje ni haber realizado ninuna \gui , se decidió descartar el lenguaje para acortar la fase de desarrollo. Sin embargo, se pretendía que el proyecto fuese ampliable a otras plataformas (Windows, Mac Os X\ldots), así que se decidió utilizar C++ que, junto a las librerías Qt, satisfacían esta premisa.\\

Se realizaron pruebas sencillas con la librería Qt, interacción entre widgets \ver{prueba1} , mostrar elementos en tablas, lectura/escritura en ficheros. Con estas pruebas se fue directo al grano en el desarrollo del proyecto.
 Esto supuso un cúmulo de problemas que se tuvo que estudiar la solución, el principal problema fue que el escaneo lo tenia que hacer de forma continua, bloqueando el resto del programa y haciendo que el sistema se volviera muy lento. %Para solucionar éste problema, se estudió el capítulo 14 del libro \cite{Blanchette}, multithreading.\\

\item \underline{Diseño de la interfaz}\\

La interfaz fue diseñada siguiendo el diseño del programa NetSurveyor, por lo que en este punto, no hubo dificultad al realizar el diseño. El IDE QtCreator incorpora en su interfaz un apartado para esta tarea. También existe el IDE QtDesigner, que combinado con QDevelop, realiza la misma tarea que QtCreator, así pues, podríamos considerar QtCreator como una suite de programacion Qt.\\

\item \underline{Adquisición de datos}\\
Para la adquisición de datos desde el comando \textit{iwlist wlan0 scan} se prefirió utilizar un comando de ejecución de procesos, volcando los resultados en un fichero. Esto facilitará posteriormente la elección de la tarjeta \wifi y la posibilidad de actualización de las herramientas iwtools.\\
El principal problema al tomar los datos fue que se usó el descriptor stdin ($>>$), el cual da la facilidad de poder tomar los datos por separado, ya que considera los espacios como separadores. Esto supone un problema cuando el ESSID (el nombre de la red) contiene varias palabras, ya que sólo toma la primera de ellas. Se descubrió que hay un flag que evita que corte el flujo de datos por lectura de espacios, noskipws (no skip white spaces), se realizaron pruebas con éste flag pero no resultaron satisfactorias, el código no leía correctamente la ESSID. Finalmente, se decidió optar por utilizar la función getline\footnote{istream\& getline (char* s, streamsize n, char delim );}.
También se definieron dos funciones, una para cortar una cadena `split'\footnote{void splitstring(string str, string separator, string \&first, string \&second);} y otra para desechar la primera parte de la cadena `limpiar'\footnote{void limpiar(string str, string separator, string \&resultado);}. \\

\item \underline{Integración del código en el proyecto}\\

La integración del hito de adquisición de datos con el del diseño de la interfaz descubrió un problema que no se había tenido en cuenta, el escaneo contínuo de la tarjeta \wifi bloqueaba el programa. Esto hizo necesario incorporar un thread al programa, el cual será el encargado de realizar esta tarea.\\
Esto produjo una parada en el desarrollo del proyecto, no se había tenido en cuenta esta estrategia y tuvo que estudiarse cómo programar threads. Para ello, se estudió el capítulo 14 del libro C++ GUI Programming with Qt4\cite{Blanchette}.\\

\figura{0.7}{imgs/capturas/threads.png}{Ejemplo de uso de threads del libro usado}{threads}{h}

Una vez solucionado éste problema, se procedió a mostrar los datos en una lista tipo TreeView, generar los gráficos, los informes (pdf y html)\ldots Para mostrar los datos en el TreeView, se encontraron dificultades debido a que se necesitaba crear un model estándar de item, pero no se conseguía que mostrara los datos, así pues, se estudio el capítulo de tablas y listas del libro \cite{Thelin}. Finalmente, se descubrió que se necesitaba crear un ItemDelegate.

\lstinputlisting[language=c++,caption={ItemDelegate implementado en el código}]{src/itemDelegate.h}


\item \underline{Estudio de Gnuplot}\\
Para estudio de GnuPlot se decidió hacer pruebas de gráficos con una batería de datos ya preparados, se limitó el uso de éste a generar un script que preparase el programa para realizar el gráfico resultante y un fichero con los datos a mostrar.\\

\lstinputlisting[language=java,caption={Ejemplo de script para Gnuplot}]{src/gnuplot1.plt}




\item \underline{Tests}\\
Se procedió a las pruebas de la aplicación en diversos lugares, tanto en la Universidad, como en la biblioteca municipal de Onda, en casa del alumno con las redes de los vecinos y añadiendo routers \wifi desechados, en cafeterías con servicio \wifi \ldots Se procedió al análisis de los datos y se encontró un problema extraño, la lectura de la señal a veces lee valores incorrectos. La primera hipótesis fue un error de programacion en la lectura de ese dato, y se procedió a analizar (se especulaba que tomaba el valor negativo de forma incorrecta), pero no se encontró el error. Se procedió entonces a realizar pruebas sin la llamada al procesi \textit{iwlist wlan0 scan}, utilizando una captura de datos previa. Esto debería permitir contrastar la hipótesis y, por tanto, solucionar este problema. No se encontró el error, pero la aplicación seguía leyendo de vez en cuando valores extraños.\\


\figura{0.5}{imgs/capturas/capturaerronea2.png}{Vista de una lectura errónea}{erronea}{h}
\figura{0.5}{imgs/capturas/capturaerronea.png}{Vista de una lectura errónea}{erronea2}{h}


\end{enumerate} 


\section{Resultados}
Se han alcanzado los objetivos iniciales del proyecto, se pretendía hacer una \gui para mostrar datos de redes inalámbricas. Se ha realizado un script de compilación e instalación del programa y se ha desarrollado con unas herramientas que permiten que las futuras extensiones sean multiplataforma.\\

Esta aplicación puede ser interesante para análisis e instalación de redes \wifi en cualquier ámbito (industrial o doméstico), ya que  permite analizar qué canales están ocupados y, con ello, evitar interferencias por solapamiento de canal. Este tipo de interferencias hace que la transmisión de datos sea lenta e ineficiente.\\


\section{Posibles extensiones}
Este proyecto podría aumentar su funcionalidad:
\begin{itemize}
\item Añadiendo un histórico de intensidad de señal en los canales.
\item Permitiendo la selección de una red en el TreeView para su análisis individual.
\item Almacenando los valores tomados en un análisis para un análisis posterior o ampliación de los datos tomados.
\end{itemize}

